package engine

import (
	"log"
	"sync"
	"time"
)

type Candle struct {
	Time  time.Time
	Close float64
}

// Strategy interface defines the contract for trading strategies
type Strategy interface {
	OnCandle(c Candle) Signal
}

// Signal represents a trading signal generated by a strategy
type Signal struct {
	Action string // "BUY", "SELL", "HOLD"
	Qty    float64
}

type Engine struct {
	portfolio *Portfolio
	broker    *SimBroker
	workers   int
	strategy  Strategy
}

func NewEngine(fees, slippage float64, workers int, strategy Strategy) *Engine {
	portfolio := &Portfolio{}
	broker := &SimBroker{
		portfolio: portfolio,
		fees:      fees,
		slippage:  slippage,
	}

	return &Engine{
		portfolio: portfolio,
		broker:    broker,
		workers:   workers,
		strategy:  strategy,
	}
}

func (e *Engine) Run(feed <-chan Candle) {
	var wg sync.WaitGroup

	// Start workers
	for i := 0; i < e.workers; i++ {
		wg.Add(1)
		go func(workerID int) {
			defer wg.Done()

			// Each worker reads from the same feed independently
			for candle := range feed {
				log.Printf("Worker %d: Candle time: %v, Close price: %f", workerID, candle.Time, candle.Close)

				// Send candle to Strategy.OnCandle()
				signal := e.strategy.OnCandle(candle)

				// Process signal if not HOLD
				if signal.Action != "HOLD" {
					// Create OrderIntent from Signal
					order := OrderIntent{
						Symbol:   "BTC", // Default symbol, should be configurable
						Side:     signal.Action,
						Quantity: signal.Qty,
						Price:    candle.Close,
					}

					// Send Signal to SimBroker
					fill := e.broker.ExecuteOrder(order)
					log.Printf("Worker %d: Executed %s order, Fill: %+v", workerID, signal.Action, fill)
				}
			}
		}(i)
	}

	wg.Wait()
}
